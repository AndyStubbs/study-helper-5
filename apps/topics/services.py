#topics/services

import random
import re

from datetime import datetime
from django.db.models import Func, Q, F
from django.utils import timezone
from django.core.exceptions import ObjectDoesNotExist
from apps.topics.models import Topic, Question, Concept, UserKnowledge
from services.ai_services import (
	create_questions,
	evaluate_topic,
	summarize_topic,
	generate_concepts,
	generate_question_concepts,
	suggest_topics
)

def get_next_question( topic_id ):
	topic = Topic.objects.get( id=topic_id )

	# Pick a random concept associated with the topic
	concept_ids = topic.concepts.values_list( "id", flat=True )
	if not concept_ids:
		raise ValueError( "No concepts found for the topic." )
	selected_concept_id  = random.choice( concept_ids )
	selected_concept = Concept.objects.get( id=selected_concept_id )
	print( f"Selected concept: {selected_concept.name}" )

	 # Count the number of questions linked to the selected concept
	question_count = Question.objects.filter( topic=topic, concepts=selected_concept ).count()
	
	# Either generate new question or use question from database based on random chance
	q_scale = 20
	generate_new_chance = max( 1, q_scale - question_count )
	if random.randint( 0, q_scale ) <= generate_new_chance:
		print( "GENERATING NEW QUESTIONS" )

		# Get previously asked questions text
		previously_asked_questions = list(
			Question.objects.filter( topic=topic, concepts=selected_concept ).values_list(
				"text", flat=True
			)
		)

		# Generate the new questions
		questions_data = create_questions(
			topic.name,
			topic.description,
			selected_concept.name,
			previously_asked_questions
		)

		# Check if there are any questions generated
		if not questions_data.questions:
			raise ValueError( "No questions generated by the AI." )

		# Create list of concepts from the topic
		concepts_str = ",".join( [ concept.name for concept in topic.concepts.all() ] )
		
		# Create a list of question text
		questions_str = "\n".join( [ q.text for q in questions_data.questions ] )
		
		# Generate filtered question concepts
		gen_questions_concepts = generate_question_concepts( concepts_str, questions_str )
		questions_concepts = gen_questions_concepts.questions_concepts
		
		# Save all the generated questions
		saved_questions = []
		for i, question_data in enumerate(questions_data.questions):
			print( f"New Question: {question_data.text}" )

			# Get concept instances and associate them with the question
			question_concepts = questions_concepts[ i ]
			concept_instances = []
			for concept_name in question_concepts:
				normalized_name = normalize_concept_name( concept_name )
				concept = Concept.objects.filter( normalized_name=normalized_name ).first()
				concept_instances.append( concept )
				if concept:
					concept_instances.append( concept )
				else:
					print( f"Warning: Concept '{concept_name}' not found." )

			# Create the question in the database
			question = Question.objects.create(
				topic=topic,
				text=question_data.text,
				answers=question_data.answers,
				correct=question_data.correct,
				main_concept=selected_concept
			)
			question.concepts.set( concept_instances )
			saved_questions.append( question )

		# Return a random question from new questions
		question = saved_questions[
			random.randint( 0, len( saved_questions ) - 1 )
		]
		question_response = {
			"id": question.id,
			"text": question.text,
			"answers": question.answers,
			"correct": question.correct,
			"concepts": [ concept.name for concept in question.concepts.all() ]
		}
		return {
			"status": "success",
			"data": question_response
		}
	
	# Return a random question from the database
	else:
		print( "LOADING RANDOM QUESITON FROM DB" )
		questions = list( Question.objects.filter( topic=topic ) )
		questions.sort( key=lambda q: q.question_rank() )
		choices = []
		for question in questions:
			rank = question.question_rank()
			num_copies = max( round( rank / 100 ), 1 )
			for _ in range( num_copies ):
				choices.append( question )
		question = choices[ random.randint( 0, len( choices ) - 1 ) ]
		question_response = {
			"id": question.id,
			"text": question.text,
			"answers": question.answers,
			"correct": question.correct,
			"concepts": [ concept.name for concept in question.concepts.all() ]
		}
		return {
			"status": "success",
			"data": question_response
		}

def get_topic_evaluation( topic_name ):
	ai_response = evaluate_topic( topic_name )
	response_data = {
		"description": ai_response.summary,
		"suggestions": ai_response.suggestions
	}
	return {
		"status": "success",
		"data": response_data
	}

def get_topic_suggestions( topic_name ):
	ai_response = suggest_topics( topic_name )
	response_data = {
		"suggestions": ai_response.suggestions
	}
	return {
		"status": "success",
		"data": response_data
	}

def save_topic( topic_name, topic_description, user ):
		print( "SAVING TOPIC IN SERVICE" )
		print( topic_name )

		# Check if the topic already exists
		existing_topic = Topic.objects.filter( name=topic_name ).first()

		if existing_topic:
			print( "UPDATING TOPIC" )
			existing_topic.description = topic_description
			existing_topic.save()
			response_data = {
				"id": existing_topic.id,
				"name": existing_topic.name,
				"description": existing_topic.description
			}
			print( f"Topic: {existing_topic.id} updated" )

			# Generate the concepts for the topic
			generate_topic_concepts( existing_topic.id )

			return {
				"status": "success",
				"data": response_data
			}
		else:
			print( "CREATING TOPIC" )
			# If the topic does not exist, create a new topic
			topic = Topic.objects.create(
				name=topic_name,
				description=topic_description,
				user=user
			)
			print( f"Topic: {topic.id} created" )

			# Generate the concepts for the topic
			generate_topic_concepts( topic.id )

			response_data = {
				"id": topic.id,
				"name": topic.name,
				"description": topic.description
			}
			return {
				"status": "success",
				"data": response_data
			}

def generate_topic_concepts( topic_id ):
	print("GENERATING CONCEPTS")
	topic = Topic.objects.get( id=topic_id )

	# Clear any existing concepts associated with this topic
	# This is necessary because the description could be changed which may make some concepts
	# not applicable anymore for this topic
	topic.concepts.clear()

	# Generate new concepts using AI
	ai_response = generate_concepts( topic.name, topic.description )

	for concept_name in ai_response.concepts:

		# Normalize the name for searching
		normalized_name = normalize_concept_name( concept_name )

		print( f"Normalized name: {normalized_name}" )

		# Find a similar concept name
		similar_concept = Concept.objects.filter(
			normalized_name=normalized_name
		).first()

		# Set the concept
		if similar_concept:
			concept = similar_concept
			created = False
		else:
			concept = Concept.objects.create( name=concept_name, normalized_name=normalized_name )
			created = True

		# Add the concept to the topic's concepts if it's not already linked
		if not topic.concepts.filter( id=concept.id ).exists():
			topic.concepts.add( concept )
		
		print(
			f"Concept '{concept_name}' {'created' if created else 'found'} and added to the topic."
		)

def normalize_concept_name( name ):
	return re.sub( r"[^a-zA-Z]", "", name ).lower()

def get_topic_description( topic_name ):
	ai_response = summarize_topic( topic_name )
	response_data = {
		"description": ai_response.summary
	}
	return {
		"status": "success",
		"data": response_data
	}

def set_answer( user, question_id, answer ):
	
	try:
		question = Question.objects.select_related( "topic" ).get( id=question_id )
	except ObjectDoesNotExist:
		raise ValueError( f"Question id: {question_id} not found." )
	
	# User skipped question
	if answer == "":
		question.skip_count += 1
		question.last_asked = timezone.now()
		question.save()
		return {
			"status": "success",
			"data": "Question skipped"
		}

	# Set question answered correct
	if answer == question.correct:
		is_correct = True
		question.correct_count += 1
	else:
		is_correct = False
		question.wrong_count += 1
	
	# Save question
	question.last_asked = timezone.now()
	question.save()

	# Update user knowledge for main concept
	update_user_knowledge( user, question.topic, question.main_concept, is_correct, True )

	# Update user knowledge for other concepts
	for concept in question.concepts.exclude( id=question.main_concept.id ):
		update_user_knowledge( user, question.topic, concept, is_correct, False )
	
	return { "status": "success", "data": "Answer recorded" }

def update_user_knowledge( user, topic, concept, is_correct, is_main_concept ):

	# Get or create the UserKnowledge instance for this combination
	user_knowledge, _ = UserKnowledge.objects.get_or_create(
		user=user, topic=topic, concept=concept
	)
	
	# Define point values
	points = 1
	if is_main_concept:
		points = 5
	
	# Update the points based on whether the answer was correct
	if is_correct:
		user_knowledge.correct_points += points
	else:
		user_knowledge.wrong_points += points

	# Save the updated record
	user_knowledge.save()
